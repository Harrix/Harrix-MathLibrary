int HML_WilcoxonW(double *a, double *b, int VHML_N1, int VHML_N2, double Q)
{
/*
Функция проверяет однородность выборок по критерию Вилкосена W.
Входные параметры:
 a - первая выборка;
 b - вторая выборка;
 VHML_N1 - размер первой выборки;
 VHML_N2 - размер второй выборки;
 Q - уровень значимости. Может принимать значения:
  0.002;
  0.01;
  0.02;
  0.05;
  0.1;
  0.2.
Возвращаемое значение:
 -2 - уровень значимости выбран неправильно (не из допустимого множества);
 -1 - объемы выборок не позволяют провести проверку при данном уровне значимости (или они не положительные);
 0 - выборки не однородны  при данном уровне значимости;
 1 - выборки однородны  при данном уровне значимости;
*/
int VHML_Result;

double Lr, Rr, Wr;

VHML_Result = HML_WilcoxonW(a, b,VHML_N1, VHML_N2, Q, &Lr, &Rr, &Wr);

return VHML_Result;
}
//---------------------------------------------------------------------------

int HML_WilcoxonW(double *a, double *b, int VHML_N1, int VHML_N2, double Q, double *Lr, double *Rr, double *Wr)
{
/*
Функция проверяет однородность выборок по критерию Вилкосена W.
Входные параметры:
 a - первая выборка;
 b - вторая выборка;
 VHML_N1 - размер первой выборки;
 VHML_N2 - размер второй выборки;
 Q - уровень значимости. Может принимать значения:
  0.002;
  0.01;
  0.02;
  0.05;
  0.1;
  0.2.
 Lr - сюда возвращается значение левой границы интервала критический значений статистики W для критерия Вилкоксена;
 Rr - сюда возвращается значение правой границы интервала критический значений статистики W для критерия Вилкоксена;
 Wr - сюда возвращается значение посчитанная статистика W для критерия Вилкоксена;

Возвращаемое значение:
 -2 - уровень значимости выбран неправильно (не из допустимого множества);
 -1 - объемы выборок не позволяют провести проверку при данном уровне значимости (или они не положительные);
 0 - выборки не однородны  при данном уровне значимости;
 1 - выборки однородны  при данном уровне значимости;
*/
int VHML_Result=-2;

bool checkQ=false;
if (Q==0.002) checkQ=true;
if (Q==0.01)  checkQ=true;
if (Q==0.02)  checkQ=true;
if (Q==0.05)  checkQ=true;
if (Q==0.1)   checkQ=true;
if (Q==0.2)   checkQ=true;
if (checkQ==false) return VHML_Result;// уровень значимости выбран не допустимого множества

//проверим правильность размеров выборки
VHML_Result=-1;
if (VHML_N1<=0) return VHML_Result;
if (VHML_N2<=0) return VHML_Result;
//Если одной выборки много по числу элементов, а второй мало, то статистика выдаст некорректные результаты
if ((VHML_N1>25)&&(VHML_N2<5)) return VHML_Result;
if ((VHML_N2>25)&&(VHML_N1<5)) return VHML_Result;

int i;
double *All=new double[VHML_N1+VHML_N2];//объединенный массив
double *Rank=new double[VHML_N1+VHML_N2];//ранги

double W=0;//значение статистики критерия Вилкосена

//заполняем объединенный массив
for (i=0;i<VHML_N1;i++) All[i]=a[i];//заливаем первую выборку
for (i=0;i<VHML_N2;i++) All[i+VHML_N1]=b[i];//заливаем вторую выборку

//проставляем ранги
HML_MakeVectorOfRankForRankSelection(All, Rank,VHML_N1+VHML_N2);

//подсчитываем значение статистики W критерия Вилкосена
if (VHML_N1<=VHML_N2)
    for (i=0;i<VHML_N1;i++) W += Rank[i];
else
    for (i=0;i<VHML_N2;i++) W += Rank[i+VHML_N1];

//Границы интервала критический значений статистики W для критерия Вилкоксена
double Left;
double Right;

if ((VHML_N1<=25)&&(VHML_N2<=25))
{
    //Берем значения из таблицы
    Left=HML_LeftBorderOfWilcoxonWFromTable(VHML_N1,VHML_N2,Q/2.);
    Right=HML_RightBorderOfWilcoxonWFromTable(VHML_N1,VHML_N2,Q/2.);
    if ((Left==-1)||(Right==-1)) return -1;//При таких размерах нельзя провести корректную проверку
}
else
{
    //В таблице значений для таких объемов выборки нет, поэтому проводим пересчет
    double m,n;
    if (VHML_N1<=VHML_N2)
    {
        m=VHML_N1;
        n=VHML_N2;
    }
    else
    {
        m=VHML_N2;
        n=VHML_N1;
    }

    double MW2=2*m*(m+n+1)/2.;

    double f1=(m*(m+n+1)-1)/2.;
    double f2=sqrt(m*n*(m+n+1)/12.);

    double h;
    //Берем значения обратной функции нормального распределения при значении 1-Q/2, так как
    //мы учитываем две критические границы
    if (Q==0.002) h=3.090232;//0.999
    if (Q==0.01)  h=2.575829;//0.995
    if (Q==0.02)  h=2.326348;//0.99
    if (Q==0.05)  h=1.959964;//0.975
    if (Q==0.1)   h=1.644854;//0.95
    if (Q==0.2)   h=1.281552;//0.9

    Left=int(f1-h*f2);
    Right=MW2-Left;
}

//Теперь проведем непосредственно проверку гипотезу об однородности выборок
if ((W>=Left)&&(W<=Right))
    VHML_Result = 1;//выборки однородны
else
    VHML_Result = 0;//выборки не однородны

delete [] All;
delete [] Rank;

*Lr = Left;
*Rr = Right;
*Wr = W;

return VHML_Result;
}
//---------------------------------------------------------------------------