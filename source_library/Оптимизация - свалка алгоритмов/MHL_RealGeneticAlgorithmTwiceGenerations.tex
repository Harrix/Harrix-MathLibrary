\textbf{Входные параметры:}
 
Parameters --- Вектор параметров генетического алгоритма. Каждый элемент обозначает свой параметр:
 
 \begin{itemize}
 \item   [0] --- длина вещественной хромосомы (определяется задачей оптимизации, что мы решаем);
  \item   [1] --- число вычислений целевой функции (CountOfFitness);
  \item    [2] --- тип селекции (TypeOfSel):
 \begin{itemize}
       \item 0 --- ProportionalSelection (Пропорциональная селекция);
 
       \item 1 --- RankSelection (Ранговая селекция);
 
       \item 2 --- TournamentSelection (Турнирная селекция).
	    \end{itemize}
 
 \item [3] --- тип скрещивания (TypeOfCros):
  \begin{itemize}
       \item 0 --- SinglepointCrossover (Одноточечное скрещивание);
 
       \item 1 --- TwopointCrossover (Двухточечное скрещивание);
 
       \item 2 --- UniformCrossover (Равномерное скрещивание).
	    \end{itemize}
 
 \item [4] --- тип мутации (TypeOfMutation):
  \begin{itemize}
       \item 0 --- Weak (Слабая мутация);
 
       \item 1 --- Average (Средняя мутация);
 
       \item 2 --- Strong (Сильная мутация).
	    \end{itemize}
 
 \item [5] --- тип формирования нового поколения (TypeOfForm):
  \begin{itemize}
       \item 0 --- OnlyOffspringGenerationForming (Только потомки);
 
       \item 1 --- OnlyOffspringWithBestGenerationForming (Только потомки и копия лучшего индивида).
	    \end{itemize}
 \item [6] --- тип преобразования задачи вещественной оптимизации в задачу бинарной оптимизации (TypOfConverting);
   \begin{itemize}
        \item 0 --- IntConverting (Стандартное представление целого числа –-- номер узла в сетке дискретизации);
        \item 1 --- GrayСodeConverting (Стандартный рефлексивный Грей-код).
			    \end{itemize}
 \end{itemize}
 
 NumberOfParts --- указатель на массив: на сколько частей делить каждую вещественную координату при дискретизации (размерность Parameters[0]);
 
  Желательно брать по формуле $NumberOfParts[i]=2^k-1$, где $k$ --- натуральное число, например, 12.
  
 Left --- массив левых границ изменения каждой вещественной координаты (размерность Parameters[0]);
 
 Right --- массив правых границ изменения каждой вещественной координаты (размерность Parameters[0]);
 
 FitnessFunction --- указатель на целевую функцию (если решается задача условной оптимизации, то учет ограничений должен быть включен в эту функцию);
 
 VMHL\_ResultVector --- найденное решение (вещественный вектор);
 
 VMHL\_Result --- значение целевой функции в точке, определенной вектором VMHL\_ResultVector.

\textbf{Возвращаемое значение:} 

 1 --- завершил работу без ошибок. Всё хорошо.
 
 0 --- возникли при работе ошибки. Скорее всего в этом случае в VMHL\_ResultVector и в VMHL\_Result не содержится решение задачи.

\textbf{О функции:}

Отличается от стандартного генетического алгоритма, тем, что количество популяций в два раза больше, чем в стандартном, при сохранении остальных параметров. Чтобы не превышать число вычислений целевой функции, на четных популяциях (считается, что первая - это инициализация ГА) значения целевой функции вычисляются как среднеарифметические родителей. При этом в учете лучшего решения учитываются только решения из нечетных поколений, где целевая функция вычисляется правильно.

Алгоритм вещественной оптимизации. Ищет максимум целевой функции FitnessFunction.

Решением является вещественная строка.

Тип алгоритма: добавочный алгоритм оптимизации.

Подробное описание алгоритма можно найти тут:

\href{https://github.com/Harrix/HarrixOptimizationAlgorithms/blob/master/\_HarrixOptimizationAlgorithms.pdf}{https://github.com/Harrix/HarrixOptimizationAlgorithms}

\textbf{Примерный настройки} (для примера Вы можете поставить такие рабочие настройки):

 Parameters[0]=50;
 
Parameters[1]=100*100;

Parameters[2]=2;

Parameters[3]=2;

Parameters[4]=1;

Parameters[5]=1;

Parameters[6]=0;

Код целевой функции:
\begin{lstlisting}[caption=Оптимизируемая функция]
double Func2(double *x,int VMHL_N)
{
return -((x[0]-2)*(x[0]-2)+(x[1]-2)*(x[1]-2));
}
\end{lstlisting}