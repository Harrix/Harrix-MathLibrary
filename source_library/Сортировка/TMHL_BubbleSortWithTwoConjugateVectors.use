        int i;
        int VMHL_N=10;//Размер массива (число строк)
        double *a;
        a=new double[VMHL_N];
        int *b;
        b=new int[VMHL_N];
        int *c;
        c=new int[VMHL_N];
        for (i=0;i<VMHL_N;i++)
         {
         a[i]=MHL_RandomUniformInt(10,50);
         b[i]=MHL_RandomUniformInt(10,50);
         c[i]=MHL_RandomUniformInt(10,50);
         }

        // Например
        MHL_ShowVectorT (a,VMHL_N,"Случайный вектор", "a");
        //Случайный вектор:
        //a =
        //45	27	11	18	24	25	16	19	34	43

        MHL_ShowVectorT (b,VMHL_N,"Сопряженный вектор", "b");
        //Сопряженный вектор:
        //b =
        //33	32	24	33	32	49	33	43	25	47

        MHL_ShowVectorT (c,VMHL_N,"Сопряженный вектор", "c");
        //Сопряженный вектор:
        //c =
        //15	24	27	43	17	47	25	11	13	26

        //Вызов функции
        TMHL_BubbleSortWithTwoConjugateVectors(a,b,c,VMHL_N);

        //Используем полученный результат
        MHL_ShowVectorT (a,VMHL_N,"Отсортированный вектор", "a");
        //Отсортированный вектор:
        //a =
        //11	16	18	19	24	25	27	34	43	45

        MHL_ShowVectorT (b,VMHL_N,"Сопряженный вектор", "b");
        // Сопряженный вектор:
        //b =
        //24	33	33	43	32	49	32	25	47	33

        MHL_ShowVectorT (c,VMHL_N,"Второй сопряженный вектор", "c");
        //Второй сопряженный вектор:
        //c =
        //27	25	43	11	17	47	24	13	26	15

        delete [] a;
        delete [] b;
        delete [] c;