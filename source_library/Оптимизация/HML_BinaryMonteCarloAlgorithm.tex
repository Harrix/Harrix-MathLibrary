\textbf{Входные параметры:}

 Parameters:
 
 \begin{itemize}
 \item [0] --- длина бинарной строки (определяется задачей оптимизации, что мы решаем);
 \item [1] --- число вычислений функции пригодности (CountOfFitness);
 \end{itemize}
  
 FitnessFunction --- указатель на целевую функцию (если решается задача условной оптимизации, то учет ограничений должен быть включен в эту функцию);
 
 VHML\_ResultVector --- найденное решение (бинарный вектор);
 
 VHML\_Result --- значение функции в точке, определенной вектором VHML\_ResultVector.

\textbf{Возвращаемое значение:}
 
 1 --- завершил работу без ошибок. Всё хорошо.
 
 0 --- возникли при работе ошибки. Скорее всего в этом случае в VHML\_ResultVector и в VHML\_Result не содержится решение задачи.
 
\textbf{Пример значений рабочего вектора Parameters:}

 Parameters[0]=20;
 
 Parameters[1]=100*100;
 
 \textbf{Принцип работы:}
 
 Принцип прост. Берутся случайно CountOfFitness решений независимо друг от друга. Выбирается лучшее. Всё.
 
 \textbf{ О функции:}
 
 В простонародье алгоритм называют <<методом научного тыка>>.
 
Алгоритм оптимизации. Ищет максимум функции пригодности FitnessFunction.

Решением является бинарная строка, то есть вектор, состоящий из 0 и 1.

\begin{lstlisting}[caption=Оптимизируемая функция]
double Func(int *x,int VHML_N)
{
//Сумма всех элементов массива
return HML_SumVector(x,VHML_N);
}
//---------------------------------------------------------------------------
\end{lstlisting}