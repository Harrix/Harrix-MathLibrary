\textbf{Входные параметры:}

 Parameters:
 
 \begin{itemize}
 \item [0] --- длина вещественной строки (определяется задачей оптимизации, что мы решаем);
 \item [1] --- число вычислений функции пригодности (CountOfFitness);
 \end{itemize}
 
 Left --- массив левых границ изменения каждой вещественной координаты (размерность Parameters[0]);
 
 Right --- массив правых границ изменения каждой вещественной координаты (размерность Parameters[0]);
  
 FitnessFunction --- указатель на целевую функцию (если решается задача условной оптимизации, то учет ограничений должен быть включен в эту функцию);
 
 VMHL\_ResultVector --- найденное решение (вещественный вектор);
 
 VMHL\_Result --- значение функции в точке, определенной вектором VMHL\_ResultVector.

\textbf{Возвращаемое значение:}
 
 1 --- завершил работу без ошибок. Всё хорошо.
 
 0 --- возникли при работе ошибки. Скорее всего в этом случае в VMHL\_ResultVector и в VMHL\_Result не содержится решение задачи.
 
\textbf{Пример значений рабочего вектора Parameters:}

 Parameters[0]=5;
 
 Parameters[1]=100*100;
 
 \textbf{Принцип работы:}
 
 Принцип прост. Берутся случайно CountOfFitness решений независимо друг от друга. Выбирается лучшее. Всё.
 
 \textbf{ О функции:}
 
 В простонародье алгоритм называют <<методом научного тыка>>.
 
Алгоритм оптимизации. Ищет максимум функции пригодности FitnessFunction.

Решением является вещественная строка, то есть вектор, состоящий из 0 и 1.

\begin{lstlisting}[caption=Оптимизируемая функция]
double Func(double *x,int VMHL_N)
{
return -((x[0]-2)*(x[0]-2)+(x[1]-2)*(x[1]-2));
}
//---------------------------------------------------------------------------
\end{lstlisting}