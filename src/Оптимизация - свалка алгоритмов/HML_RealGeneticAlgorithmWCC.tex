\textbf{Входные параметры:}
 
Parameters --- Вектор параметров генетического алгоритма. Каждый элемент обозначает свой параметр:
 
 \begin{itemize}
 \item   [0] --- длина вещественной хромосомы (определяется задачей оптимизации, что мы решаем);
  \item   [1] --- число вычислений целевой функции (CountOfFitness);
  \item    [2] --- тип селекции (TypeOfSel):
 \begin{itemize}
       \item 0 --- ProportionalSelection (Пропорциональная селекция);
 
       \item 1 --- RankSelection (Ранговая селекция);
 
       \item 2 --- TournamentSelection (Турнирная селекция).
	    \end{itemize}
 
 \item [3] --- тип скрещивания (TypeOfCros):
  \begin{itemize}
       \item 0 --- SinglepointCrossoverWithCopying (Одноточечное скрещивание с возможностью полного копирования одного из родителей);
 
       \item 1 --- TwopointCrossoverWithCopying (Двухточечное скрещивание с возможностью полного копирования одного из родителей).
	    \end{itemize}
 
 \item [4] --- тип мутации (TypeOfMutation):
  \begin{itemize}
       \item 0 --- Weak (Слабая мутация);
 
       \item 1 --- Average (Средняя мутация);
 
       \item 2 --- Strong (Сильная мутация).
	    \end{itemize}
 
 \item [5] --- тип формирования нового поколения (TypeOfForm):
  \begin{itemize}
       \item 0 --- OnlyOffspringGenerationForming (Только потомки);
 
       \item 1 --- OnlyOffspringWithBestGenerationForming (Только потомки и копия лучшего индивида).
	    \end{itemize}
 \item [6] --- тип преобразования задачи вещественной оптимизации в задачу бинарной оптимизации (TypOfConverting);
   \begin{itemize}
        \item 0 --- IntConverting (Стандартное представление целого числа –-- номер узла в сетке дискретизации);
        \item 1 --- GrayСodeConverting (Стандартный рефлексивный Грей-код).
			    \end{itemize}
 \end{itemize}
 
 NumberOfParts --- указатель на массив: на сколько частей делить каждую вещественную координату при дискретизации (размерность Parameters[0]);
 
  Желательно брать по формуле $NumberOfParts[i]=2^k-1$, где $k$ --- натуральное число, например, 12.
  
 Left --- массив левых границ изменения каждой вещественной координаты (размерность Parameters[0]);
 
 Right --- массив правых границ изменения каждой вещественной координаты (размерность Parameters[0]);
 
 FitnessFunction --- указатель на целевую функцию (если решается задача условной оптимизации, то учет ограничений должен быть включен в эту функцию);
 
 VHML\_ResultVector --- найденное решение (вещественный вектор);
 
 VHML\_Result --- значение целевой функции в точке, определенной вектором VHML\_ResultVector.

\textbf{Возвращаемое значение:} 

 1 --- завершил работу без ошибок. Всё хорошо.
 
 0 --- возникли при работе ошибки. Скорее всего в этом случае в VHML\_ResultVector и в VHML\_Result не содержится решение задачи.

\textbf{О функции:}

Отличается от стандартного генетического алгоритма тем, что есть только два вида скрещивания: одноточечное и двухточечное скрещивание с возможностью полного копирования одного из родителей. Равномерное скрещивание отсутствует. То есть данным алгоритмом проверяем: есть ли разница в эффективности алгоритма, если точки разрыва при скрещивании делать и по краям родителей, а не только внутри хромосомы.

Алгоритм вещественной оптимизации. Ищет максимум целевой функции FitnessFunction.

Решением является вещественная строка.

Тип алгоритма: исследовательский алгоритм оптимизации.

Подробное описание алгоритма можно найти тут:

\href{https://github.com/Harrix/HarrixOptimizationAlgorithms/blob/master/\_HarrixOptimizationAlgorithms.pdf}{https://github.com/Harrix/HarrixOptimizationAlgorithms}

\textbf{Примерный настройки} (для примера Вы можете поставить такие рабочие настройки):

 Parameters[0]=50;
 
Parameters[1]=100*100;

Parameters[2]=2;

Parameters[3]=1;

Parameters[4]=1;

Parameters[5]=1;

Parameters[6]=0;


\textbf{Примечание:}

 В сГА на вещественных строках не нужно задавать в параметрах число поколений и размер популяции, а только число вычислений целевой функции. Почему? Алгоритм сам определит число поколений и размер популяции, исходя из принципа, что число поколений и размер популяции должны быть примерно равны. Поэтому выбирайте значение Parameters[1] в виде:

int K=100;

Parameters[1]=K*K;

То есть в виде квадрата целого числа. В противном случае реальное число вычислений целевой функции и значение Parameters[1] будут не совпадать.

Код целевой функции:
\begin{lstlisting}[caption=Оптимизируемая функция]
double Func2(double *x,int VHML_N)
{
return -((x[0]-2)*(x[0]-2)+(x[1]-2)*(x[1]-2));
}
\end{lstlisting}